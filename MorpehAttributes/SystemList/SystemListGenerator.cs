#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MorpehAttributes.Common;

namespace MorpehAttributes.SystemList;

[Generator]
public class SystemListGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SystemListSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not SystemListSyntaxReceiver receiver)
        {
            return;
        }

        foreach (var kvp in receiver.Test)
        {
            var codeBuilder = new CodeBuilder();
            var systems = kvp.Value.Select(BuildAttribute).OfType<SystemInfo>().ToList();
            
            codeBuilder.AppendLine(Const.AutoGeneratedText);
            codeBuilder.AppendEmptyLine();
            
            codeBuilder.AppendLine(Const.UtilUsings);
            var namespaces = systems
                .Select(system =>
                {
                    var semanticModel = context.Compilation.GetSemanticModel(system.TypeSyntax.SyntaxTree);
                    var typeSymbol = semanticModel.GetSymbolInfo(system.TypeSyntax).Symbol as INamedTypeSymbol;
                    var namespaceSymbol = typeSymbol?.ContainingNamespace;

                    return namespaceSymbol;
                })
                .OfType<INamespaceSymbol>()
                .Select(@namespace => @namespace.ToString())
                .Distinct();
            
            foreach (var @namespace in namespaces)
            {
                codeBuilder.AppendLine($"using {@namespace};");
            }
            
            codeBuilder.AppendEmptyLine();
            
            var classSymbol = kvp.Key;
            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                codeBuilder.AppendLine(
                    $"namespace {string.Join(".", classSymbol.ContainingNamespace.ConstituentNamespaces)}"
                );
                codeBuilder.AppendOpenBraces();
            }
            
            var containingTypes = new List<INamedTypeSymbol>();
            var containingType = classSymbol.ContainingType;
            while (containingType != null)
            {
                containingTypes.Add(containingType);
                containingType = containingType.ContainingType;
            }
            
            containingTypes.Reverse();
            foreach (var type in containingTypes)
            {
                codeBuilder.AppendLine($"public partial class {type.Name}");
                codeBuilder.AppendOpenBraces();
            }
            
            codeBuilder.AppendLine($"public partial class {classSymbol.Name}");
            codeBuilder.AppendOpenBraces();
            
            // Fields
            foreach (var system in systems)
            {
                codeBuilder.AppendLine($"private {system.TypeSyntax} {system.VarName};");
            }

            AddFunction($"public {classSymbol.Name}()", system => $"{system.VarName} = new {system.TypeSyntax}();", false);
            AddFunction("public void OnAwake()", system => $"{system.VarName}.OnAwake();");
            AddFunction("public void OnUpdate(float deltaTime)", system => $"{system.VarName}.OnUpdate(deltaTime);");
            AddFunction("public void Dispose()", system => $"{system.VarName}.Dispose();");
            
            codeBuilder.AppendCloseBraces();
            
            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                codeBuilder.AppendCloseBraces();
            }

            var classSource = codeBuilder.ToString();
            context.AddSource($"{classSymbol.Name}.g.cs", SourceText.From(classSource, Encoding.UTF8));

            void AddFunction(
                string headerLine,
                Func<SystemInfo, string> systemLine,
                bool withAttributes = true
            )
            {
                codeBuilder.AppendEmptyLine();
                if (withAttributes)
                {
                    codeBuilder.AppendLine(Const.UtilAttributes);
                }
                codeBuilder.AppendLine(headerLine);
                codeBuilder.AppendOpenBraces();
                foreach (var system in systems)
                {
                    codeBuilder.AppendLine(systemLine(system));
                }
                codeBuilder.AppendCloseBraces();
            }
        }
    }

    private static SystemInfo? BuildAttribute(AttributeSyntax attributeSyntax)
    {
        var args = attributeSyntax.ArgumentList?.Arguments.ToList();
        if (args is not { Count: 3 })
        {
            return null;
        }
        
        var typeAttributeArgument = args[0];
        var updatePhaseAttributeArgument = args[1];
        var systemTypeAttributeArgument = args[2];
        
        if (typeAttributeArgument?.Expression is not TypeOfExpressionSyntax typeOfExpression)
        {
            return null;
        }
        
        if (updatePhaseAttributeArgument?.Expression is not MemberAccessExpressionSyntax updateMemberAccessSyntax)
        {
            return null;
        }
        
        if (systemTypeAttributeArgument?.Expression is not MemberAccessExpressionSyntax systemMemberAccessSyntax)
        {
            return null;
        }

        return new(
            typeOfExpression.Type,
            updateMemberAccessSyntax.Name.ToString(),
            systemMemberAccessSyntax.Name.ToString()
        );
    }
}